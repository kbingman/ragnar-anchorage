var flight = require('flightjs');
var withObservableState = require('flight-with-observable-state');
var withBatch = require('flight-with-batch');
var withCanvas = require('with-canvas');

function tacticalUI() {
  this.attributes({
    initiallyActive: false,
    counter: 0,
    ships: [
      { x: 200, y: 120, color: 'red', v: 0.2, angle: 200, points: [] },
      { x: 600, y: 500, color: 'lime', v: 0, angle: 0, points: [] }
    ]
  });

  this.update = function(state) {
    this.node.classList.toggle('is-active', this.state.active);
  };

  this.renderShips = function() {
    window.requestAnimationFrame(this.renderShips.bind(this), this.node);
    
    this.attr.context.clearRect(0, 0, this.attr.width, this.attr.height);
    this.attr.ships.forEach(this.plotShip, this);
  };

  this.plotShip = function(ship, i, ships) {
    // debugger
    // if (ship.color == 'red') {
    //   this.attr.context.clearRect(ship.x-4, ship.y-4, 8, 8);
    // }

    var angle = ship.angle * Math.PI / 180 - Math.PI / 2;
    var ax = Math.cos(angle) * ship.v;
    var ay = Math.sin(angle) * ship.v;

    var next = ships[i + 1] ? ships[i + 1] : ships[0];
    var dx = ship.x - next.x;
    var dy = ship.y - next.y;
    var h = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

    this.drawCircle({
      x: ship.x,
      y: ship.y,
      radius: 2,
      stroke: 0,
      fill: ship.color
    });

    ship.x = ship.x + ax;
    ship.y = ship.y + ay;

    if (ship.color == 'lime') {
      if (isNaN(h)) {
        ship.angle = 1;
      } else {
        ship.angle = (Math.asin(Math.round(dy) / h) * 180) + 180;
      }
      ship.v += 0.3;
    }

    this.attr.counter++
  };

  this.after('initialize', function() {
    this.on(document, 'showTacticalUI', this.setupCanvas);
    this.on(document, 'showTacticalUI', function() {
      this.attr.start = +new Date();
      this.node.classList.remove('isHidden');
      this.renderShips();

      console.log('duration', +new Date() - this.attr.start);
    });
  });
}

module.exports = flight.component(
  withObservableState,
  withBatch,
  withCanvas,
  tacticalUI
);
